package edu.sb.cookbook.service;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.validation.constraints.Positive;
import javax.validation.constraints.PositiveOrZero;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import edu.sb.cookbook.persistence.Document;
import edu.sb.cookbook.persistence.IngredientType;
import edu.sb.cookbook.persistence.Person;
import edu.sb.cookbook.persistence.Recipe;

@Path("persons")
public class PersonService {

    @PersistenceContext
    private EntityManager entityManager;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response queryPeople(
            @QueryParam("result-offset") @PositiveOrZero Integer resultOffset,
            @QueryParam("result-limit") @PositiveOrZero Integer resultLimit
    ) {
        try {
            TypedQuery<Long> query = entityManager.createQuery("SELECT p.id FROM Person p", Long.class);
            if (resultOffset != null) query.setFirstResult(resultOffset);
            if (resultLimit != null) query.setMaxResults(resultLimit);

            List<Long> personIds = query.getResultList();
            List<Person> people = personIds.stream()
                    .map(id -> entityManager.find(Person.class, id))
                    .sorted(Comparator.comparing(Person::getName).thenComparing(Person::getEmail))
                    .collect(Collectors.toList());

            return Response.ok(people).build();
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.TEXT_PLAIN)
    public Response createOrUpdatePerson(
            @HeaderParam(BasicAuthenticationReceiverFilter.REQUESTER_IDENTITY) @Positive long requesterIdentity,
            Person person
    ) {
        try {
            // Check if the requester is an admin or the person itself
            if (isAdministrator(requesterIdentity) || requesterIdentity == person.getIdentity()) {
                // Associate default avatar if none is provided
            	if (person.getAvatar() == null) {
            	    Document defaultAvatar = entityManager.find(Document.class, 0); // TODO: which ID is default avatar?
            	    person.setAvatar(defaultAvatar);
            	}
                // Optionally, set a new password using the "X-Set-Password" header field
                // TODO: setting password if needed
                entityManager.merge(person);
                return Response.ok(person.getIdentity()).build();
            } else {
                return Response.status(Response.Status.FORBIDDEN).entity("Only administrators or the person itself may perform this operation.").build();
            }
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    @DELETE
    @Path("{id}")
    @Produces(MediaType.TEXT_PLAIN)
    public Response deletePerson(
            @PathParam("id") @Positive long id
    ) {
        try {
            Person person = entityManager.find(Person.class, id);
            if (person == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            }
            // Check if the requester is an admin or the matching person
            if (isAdministrator(id) || id == person.getIdentity()) {
                // TODO: Dissociate associated recipes and ingredient types
                // TODO: Code for dissociating recipes and ingredient types
                entityManager.remove(person);
                return Response.ok().build();
            } else {
                return Response.status(Response.Status.FORBIDDEN).entity("Only administrators or the person itself may perform this operation.").build();
            }
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    @GET
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response findPerson(
            @PathParam("id") @Positive long id
    ) {
        try {
            Person person = entityManager.find(Person.class, id);
            if (person == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            } else {
                return Response.ok(person).build();
            }
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    @GET
    @Path("requester")
    @Produces(MediaType.APPLICATION_JSON)
    public Response findRequester(
            @HeaderParam("X-Requester-Identity") @Positive long requesterIdentity
    ) {
        try {
            Person person = entityManager.find(Person.class, requesterIdentity);
            if (person == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            } else {
                return Response.ok(person).build();
            }
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    // Implement other methods as per requirements
    private boolean isAdministrator(long requesterIdentity) {
        // TODO: check if the requester is an administrator
        return true;
    }
	
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("{id}/recipes")
    public Response getRecipes(@PathParam("id") @Positive long id) {
        try {
            Person person = entityManager.find(Person.class, id);
            if (person == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            }
            List<Recipe> recipes = person.getRecipes().stream()
                    .sorted(Comparator.comparing(Recipe::getIdentity))
                    .collect(Collectors.toList());
            return Response.ok(recipes).build();
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("{id}/ingredient-types")
    public Response getIngredientTypes(@PathParam("id") @Positive long id) {
        try {
            Person person = entityManager.find(Person.class, id);
            if (person == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            }
            List<IngredientType> ingredientTypes = person.getIngredientTypes().stream()
                    .sorted(Comparator.comparing(IngredientType::getIdentity))
                    .collect(Collectors.toList());
            return Response.ok(ingredientTypes).build();
        } catch (Exception e) {
            return Response.serverError().entity(e.getMessage()).build();
        }
    }

}
