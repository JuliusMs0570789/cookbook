package edu.sb.cookbook.service;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.validation.constraints.Positive;
import javax.validation.constraints.PositiveOrZero;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import edu.sb.cookbook.persistence.Document;
import edu.sb.cookbook.persistence.IngredientType;
import edu.sb.cookbook.persistence.Person;
import edu.sb.cookbook.persistence.Person.Group;
import edu.sb.cookbook.persistence.Recipe;
import edu.sb.tool.RestJpaLifecycleProvider;

@Path("persons")
public class PersonService {

	@PersistenceContext
	private EntityManager entityManager;

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	public Person[] queryPeople(
			/*
			 * Returns the people matching the given filter criteria, with missing
			 * parameters identifying omitted criteria. Search criteria should be query
			 * parameters containing any “normal” property of both people and their
			 * composites, except identity and passwordHash, plus int values for
			 * result-offset and result-limit which define a paging range.
			 */
			@QueryParam("result-offset") @PositiveOrZero Integer resultOffset,
			@QueryParam("result-limit") @PositiveOrZero Integer resultLimit,
			@QueryParam("lower-created") final String lowerCreated,
			@QueryParam("upper-created") final String upperCreated,
			@QueryParam("lower-modified") final String lowerModified,
			@QueryParam("upper-modified") final String upperModified, @QueryParam("title") final String title,
			@QueryParam("familyName") final String familyName, @QueryParam("givenName") final String givenName,
			@QueryParam("email") final String email, @QueryParam("street") final String street,
			@QueryParam("city") final String city, @QueryParam("postcode") final String postcode,
			@QueryParam("country") final String country, @QueryParam("group") final Group group) {
		/**
		 * The JPA query should return the matching Person-IDs, which are used
		 * subsequently to query the people from the 2nd level cache using
		 * "entityManager.find()", and then sorted by name and email → best use
		 * Collection-Streams for the latter two steps.
		 */
		final EntityManager entityManager = RestJpaLifecycleProvider.entityManager("cookbook");
		final TypedQuery<Long> query = entityManager.createQuery("SELECT person.identity FROM Person AS person WHERE "
				+ "(:lowerCreated is null or person.created >= :lowerCreated) and "
				+ "(:upperCreated is null or person.created <= :upperCreated) and "
				+ "(:lowerModified is null or person.modified >= :lowerModified) and "
				+ "(:upperModified is null or person.modified <= :upperModified) and "
				+ "(:title is null or person.name.title = :title) AND "
				+ "(:familyName is null or person.name.family = :familyName) AND " //TODO and and from where ändern
				+ "(:givenName is null or person.name.given = :givenName) AND "			
				+ "(:email is null or person.email = :email) AND "
				+ "(:street is null or person.address.street = :street) AND "
				+ "(:city is null or person.address.city = :city) AND "
				+ "(:postcode is null or person.address.postcode = :postcode) AND "
				+ "(:country is null or person.address.country = :country) AND "
	            + "(:group is null or person.group = :group)", Long.class);
        if (resultOffset != null) query.setFirstResult(resultOffset);
        if (resultLimit != null) query.setMaxResults(resultLimit);
    	static private final Comparator<Person> COMPARATOR = Comparator
                .comparing(Person::getName)
                .thenComparing(Person::getEmail); 
		final Person[] people = query
        		.setParameter("lowerCreated", lowerCreated)
				.setParameter("upperCreated", upperCreated)
				.setParameter("lowerModified", lowerModified)
				.setParameter("upperModified", upperModified)
		        .setParameter("title", title)
		        .setParameter("familyName", familyName)
		        .setParameter("givenName", givenName)              
		        .setParameter("email", email)
		        .setParameter("street", street)
		        .setParameter("city", city)
		        .setParameter("postcode", postcode)
		        .setParameter("country", country)
		        .setParameter("group", group)
		        .getResultList()
		        .stream()
		        .map(identity -> entityManager.find(Person.class, identity))
		        .filter(person -> person != null)
		        .sorted(COMPARATOR)
		        .toArray(Person[]::new);

		return people;

	}

	/*
	 * @GET
	 * 
	 * @Produces(MediaType.APPLICATION_JSON) public Response
	 * queryPeople(@QueryParam("result-offset") @PositiveOrZero Integer
	 * resultOffset,
	 * 
	 * @QueryParam("result-limit") @PositiveOrZero Integer resultLimit) { try {
	 * TypedQuery<Person> query =
	 * entityManager.createQuery("SELECT p FROM Person p ORDER BY p.name, p.email",
	 * Person.class); if (resultOffset != null) query.setFirstResult(resultOffset);
	 * if (resultLimit != null) query.setMaxResults(resultLimit);
	 * 
	 * List<Person> people = query.getResultList();
	 * 
	 * return Response.ok(people).build(); } catch (Exception e) { return
	 * Response.serverError().entity(e.getMessage()).build(); } }
	 */

	/**
	 * Otherwise it updates the corresponding person with the given template data,
	 * which only adminstrators or the person itself may perform. Make sure
	 * non-administrators cannot upgrade their group. Optionally, a new password may
	 * be set using the header field “X-Set-Password”. Returns the affected person's
	 * identity as text/plain. Only Admintrators or the given person may perform
	 * this operation.
	 */

	// HTTP Signature: POST people (in: JSON, out: text/plain)
	// HTTP Signature: POST people (in: JSON, out: text/plain)
	@POST
	@Consumes(MediaType.APPLICATION_JSON)
	@Produces(MediaType.TEXT_PLAIN)
	public Response createOrUpdatePerson(@HeaderParam("X-Requester-Identity") @Positive long requesterIdentity,
			Person person) {
		try {
			if (!isAdministrator(requesterIdentity) && requesterIdentity != person.getIdentity()) {
				return Response.status(Response.Status.FORBIDDEN)
						.entity("Only administrators or the person itself may perform this operation.").build();
			}

			if (person.getIdentity() == 0) {
				if (!isAdministrator(requesterIdentity)) {
					return Response.status(Response.Status.FORBIDDEN)
							.entity("Only administrators may create a new person with identity zero.").build();
				}
				Document defaultAvatar = entityManager.find(Document.class, 1);
				person.setAvatar(defaultAvatar);

				entityManager.persist(person);
			} else {
				Person existingPerson = entityManager.find(Person.class, person.getIdentity());
				if (existingPerson == null) {
					return Response.status(Response.Status.NOT_FOUND)
							.entity("Person not found for the provided identity.").build();
				}
				if (!isAdministrator(requesterIdentity) && requesterIdentity != existingPerson.getIdentity()) {
					return Response.status(Response.Status.FORBIDDEN)
							.entity("Only administrators or the person itself may update this person's data.").build();
				}
				if (person.getAvatar() == null) {
					Document defaultAvatar = entityManager.find(Document.class, 1);
					person.setAvatar(defaultAvatar);
				}

				// TODO: What else to update?

				existingPerson.setEmail(person.getEmail());
				existingPerson.setAvatar(person.getAvatar());

				// TODO: Set password

				entityManager.merge(existingPerson);

			}

			return Response.ok(person.getIdentity()).build();
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	/**
	 * HTTP Signature: DELETE people/{id} (in: -, out: text/plain) Deletes the
	 * person matching the given identity. This must not cascade deletion to the
	 * recipes and ingredient types owned by the matching person, but set their
	 * respective owner to null. Only Admintrators or the matching person may
	 * perform this operation.
	 */
	@DELETE
	@Path("{id}")
	@Produces(MediaType.TEXT_PLAIN)
	public Response deletePerson(@PathParam("id") @Positive long id) {
		try {
			Person person = entityManager.find(Person.class, id);
			if (person == null) {
				return Response.status(Response.Status.NOT_FOUND).build();
			}

			if (!isAdministrator(id) && id != person.getIdentity()) {
				return Response.status(Response.Status.FORBIDDEN)
						.entity("Only administrators or the person itself may perform this operation.").build();
			}

			person.getRecipes().forEach(recipe -> recipe.setOwner(null));
			person.getIngredientTypes().forEach(ingredientType -> ingredientType.setOwner(null));

			entityManager.remove(person);
			return Response.ok().build();
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	/**
	 * HTTP Signature: GET people/{id} (in:- out: application/json) Returns the
	 * person matching the given identity.
	 */
	@GET
	@Path("{id}")
	@Produces(MediaType.APPLICATION_JSON)
	public Response findPerson(@PathParam("id") @Positive long id) {
		try {
			Person person = entityManager.find(Person.class, id);
			if (person == null) {
				return Response.status(Response.Status.NOT_FOUND).build();
			} else {
				return Response.ok(person).build();
			}
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	/**
	 * HTTP Signature: GET people/requester (in:- out: application/json) Returns the
	 * person matching the given header field “X-Requester-Identity”. Note that this
	 * header field is injected during successful authentication.
	 */
	@GET
	@Path("requester")
	@Produces(MediaType.APPLICATION_JSON)
	public Response findRequester(@HeaderParam("X-Requester-Identity") @Positive long requesterIdentity) {
		try {
			Person person = entityManager.find(Person.class, requesterIdentity);
			if (person == null) {
				return Response.status(Response.Status.NOT_FOUND).build();
			} else {
				return Response.ok(person).build();
			}
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	/**
	 * HTTP Signature: GET people/{id}/recipes (in:- out: application/json) Returns
	 * the recipes associated with an owner matching the given identity, sorted by
	 * ID.
	 */
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("{id}/recipes")
	public Response getRecipes(@PathParam("id") @Positive long id) {
		try {
			Person person = entityManager.find(Person.class, id);
			if (person == null) {
				return Response.status(Response.Status.NOT_FOUND).build();
			}
			List<Recipe> recipes = person.getRecipes().stream().sorted(Comparator.comparing(Recipe::getIdentity))
					.collect(Collectors.toList());
			return Response.ok(recipes).build();
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	/**
	 * HTTP Signature: GET people/{id}/ingredient-types (in:- out: application/json)
	 * Returns the ingredient types associated with an owner matching the given
	 * identity, sorted by ID.
	 */
	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Path("{id}/ingredient-types")
	public Response getIngredientTypes(@PathParam("id") @Positive long id) {
		try {
			Person person = entityManager.find(Person.class, id);
			if (person == null) {
				return Response.status(Response.Status.NOT_FOUND).build();
			}
			List<IngredientType> ingredientTypes = person.getIngredientTypes().stream()
					.sorted(Comparator.comparing(IngredientType::getIdentity)).collect(Collectors.toList());
			return Response.ok(ingredientTypes).build();
		} catch (Exception e) {
			return Response.serverError().entity(e.getMessage()).build();
		}
	}

	// Implement other methods as per requirements
	private boolean isAdministrator(long requesterIdentity) {
		// TODO: check if the requester is an administrator
		return true;
	}

}
